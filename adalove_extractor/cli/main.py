"""
Ponto de entrada principal para execu√ß√£o do extrator.

Este m√≥dulo implementa a l√≥gica de extra√ß√£o completa usando a arquitetura modular
com sistema resiliente de checkpoints e recupera√ß√£o autom√°tica.
"""

import asyncio
import time
from datetime import datetime
from playwright.async_api import async_playwright

from ..config import get_settings, configure_logging
from ..browser import login_adalove, navigate_to_academic_life, discover_weeks
from ..extractors import extract_week_cards
from ..enrichment import EnrichmentEngine
from ..io import (
    write_cards_csv, write_enriched_outputs, compute_stats_by_week,
    CheckpointManager, IncrementalWriter, RecoveryManager
)


async def run_extraction(nome_turma: str) -> None:
    """
    Executa o fluxo completo de extra√ß√£o para uma turma com sistema resiliente.
    
    Fluxo:
    1. Detec√ß√£o de execu√ß√£o interrompida
    2. Login na plataforma
    3. Navega√ß√£o para academic-life
    4. Sele√ß√£o manual da turma
    5. Descoberta de semanas
    6. Extra√ß√£o de cards por semana com checkpoints
    7. Enriquecimento de dados
    8. Exporta√ß√£o para CSV/JSONL
    
    Args:
        nome_turma: Nome da turma para organiza√ß√£o dos arquivos
    """
    settings = get_settings()
    logger = configure_logging(nome_turma, settings.logs_dir, "DEBUG")
    
    print("\n" + "="*60)
    print("üöÄ ADALOVE CARDS EXTRACTOR - VERS√ÉO 3.1.0 (RESILIENTE)")
    print("="*60)
    print("üìã Extra√ß√£o completa incluindo:")
    print("   ‚úÖ T√≠tulos e descri√ß√µes dos cards")
    print("   ‚úÖ Links e materiais anexados")
    print("   ‚úÖ Arquivos e documentos")
    print("   ‚úÖ Organiza√ß√£o por pasta da turma")
    print("   ‚úÖ Enriquecimento e ancoragem de autoestudos")
    print("   ‚úÖ Sistema de checkpoints e recupera√ß√£o autom√°tica")
    print("="*60)
    
    logger.info(f"üöÄ Iniciando extra√ß√£o resiliente para turma: {nome_turma}")
    
    # 1. DETEC√á√ÉO DE EXECU√á√ÉO INTERROMPIDA
    recovery_mgr = RecoveryManager(nome_turma, settings.output_dir)
    
    if recovery_mgr.detect_interrupted():
        logger.info("‚ö†Ô∏è Execu√ß√£o anterior detectada")
        
        # Mostra informa√ß√µes da execu√ß√£o anterior
        checkpoint = recovery_mgr.load_checkpoint()
        print(f"\n‚ö†Ô∏è  EXECU√á√ÉO ANTERIOR DETECTADA!")
        print(f"üìä Progresso: {len(checkpoint['semanas_processadas'])}/{len(checkpoint['semanas_descobertas'])} semanas")
        print(f"üìù Cards extra√≠dos: {checkpoint['cards_extraidos']}")
        print(f"‚è∞ √öltima atualiza√ß√£o: {checkpoint['ultima_atualizacao']}")
        
        opcao = recovery_mgr.prompt_recovery()
        
        if opcao == 'continue':
            # RETOMAR EXECU√á√ÉO
            logger.info("üîÑ Retomando execu√ß√£o anterior")
            return await resume_extraction(nome_turma, recovery_mgr, settings, logger)
        elif opcao == 'restart':
            # LIMPAR E RECOME√áAR
            logger.info("üßπ Limpando execu√ß√£o anterior e recome√ßando")
            recovery_mgr.cleanup_all()
            print("üßπ Limpeza conclu√≠da. Iniciando nova extra√ß√£o...")
        else:  # abort
            logger.info("‚ùå Usu√°rio abortou execu√ß√£o")
            print("‚ùå Execu√ß√£o abortada pelo usu√°rio")
            return
    
    # 2. NOVA EXECU√á√ÉO COM CHECKPOINTS
    execution_id = f"{nome_turma}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    checkpoint_mgr = CheckpointManager(nome_turma, settings.output_dir, execution_id)
    incremental_writer = IncrementalWriter(nome_turma, settings.output_dir, execution_id)
    
    start_time = time.time()
    
    async with async_playwright() as p:
        browser = await p.chromium.launch(
            channel=settings.browser_channel, 
            headless=settings.headless
        )
        page = await browser.new_page()
        
        try:
            # Login
            await page.goto("https://adalove.inteli.edu.br/")
            if not await login_adalove(page, settings.login, settings.senha, logger):
                logger.error("‚ùå Falha no login")
                return
            
            # Academic-life
            await navigate_to_academic_life(page, logger)
            
            # Sele√ß√£o manual da turma
            if settings.interactive:
                print(f"\nüìÅ Dados ser√£o salvos em: {settings.output_dir}/{nome_turma}/")
                print("üëÜ Agora selecione a turma na interface:")
                try:
                    input("‚è∏Ô∏è Pressione Enter ap√≥s selecionar a turma na p√°gina: ")
                    logger.info("‚úÖ Turma selecionada")
                    await page.wait_for_timeout(3000)
                except (EOFError, KeyboardInterrupt):
                    print("\n‚ùå Entrada cancelada pelo usu√°rio")
                    return
                
                # Fecha popup novamente
                try:
                    fechar_btn = page.locator("button:has-text('Fechar')").first
                    if await fechar_btn.is_visible(timeout=2000):
                        await fechar_btn.click()
                        await page.wait_for_timeout(1000)
                except Exception:
                    pass
            
            # Descobre semanas
            semanas = await discover_weeks(page, logger)
            
            # Inicializa checkpoint
            checkpoint_mgr.initialize(semanas)
            logger.info(f"üìö Processando {len(semanas)} semanas com checkpoints...")
            
            # LOOP POR SEMANAS COM SALVAMENTO INCREMENTAL
            for i, semana in enumerate(semanas, 1):
                logger.info(f"üîÑ {semana} ({i}/{len(semanas)})")
                
                # Volta para academic-life antes de cada semana
                await page.goto("https://adalove.inteli.edu.br/academic-life")
                await page.wait_for_timeout(2000)
                
                # Fecha popup
                try:
                    fechar_btn = page.locator("button:has-text('Fechar')").first
                    if await fechar_btn.is_visible(timeout=2000):
                        await fechar_btn.click()
                        await page.wait_for_timeout(1000)
                except Exception:
                    pass
                
                # Extrai cards da semana
                cards_semana = await extract_week_cards(page, semana, logger)
                
                # SALVAMENTO INCREMENTAL (ap√≥s cada semana)
                incremental_writer.write_batch(cards_semana)
                incremental_writer.flush()
                
                # Cria backup da semana
                incremental_writer.create_week_backup(semana, cards_semana)
                
                # ATUALIZA CHECKPOINT
                checkpoint_mgr.mark_week_completed(semana, len(cards_semana))
                checkpoint_mgr.save()
                
                logger.info(f"‚úÖ Checkpoint: {semana} salva ({len(cards_semana)} cards)")
            
            # FINALIZA√á√ÉO
            checkpoint_mgr.mark_as_completed()
            all_cards = incremental_writer.finalize()  # Consolida JSONL temp
            
            # Salva arquivos finais + enriquecimento
            await save_and_enrich(all_cards, nome_turma, settings.output_dir, logger)
            
            # Limpeza de arquivos tempor√°rios
            checkpoint_mgr.cleanup()
            incremental_writer.cleanup()
            
            # Resumo final
            duration = time.time() - start_time
            print_final_summary(all_cards, nome_turma, settings.output_dir, duration, logger)
            
        except Exception as e:
            # MARCA CHECKPOINT COMO FAILED (se foi inicializado)
            try:
                checkpoint_mgr.mark_as_failed(str(e))
                checkpoint_mgr.save()
            except RuntimeError:
                # Checkpoint n√£o foi inicializado ainda
                pass
            logger.error(f"‚ùå Erro geral: {e}")
            raise
        finally:
            await browser.close()


async def resume_extraction(
    nome_turma: str, 
    recovery_mgr: RecoveryManager, 
    settings, 
    logger
) -> None:
    """
    Retoma extra√ß√£o interrompida do √∫ltimo checkpoint.
    
    Args:
        nome_turma: Nome da turma
        recovery_mgr: Inst√¢ncia do RecoveryManager
        settings: Configura√ß√µes do sistema
        logger: Logger
    """
    checkpoint = recovery_mgr.load_checkpoint()
    execution_id = checkpoint['execution_id']
    
    # Carrega dados j√° extra√≠dos
    cards_existentes = recovery_mgr.load_temp_data()
    logger.info(f"üì¶ Carregados {len(cards_existentes)} cards do checkpoint")
    
    # Retoma writer e checkpoint manager
    checkpoint_mgr, incremental_writer = recovery_mgr.resume_from(execution_id)
    
    semanas_pendentes = [
        s for s in checkpoint['semanas_descobertas'] 
        if s not in checkpoint['semanas_processadas']
    ]
    
    logger.info(f"üîÑ Retomando extra√ß√£o. Faltam {len(semanas_pendentes)} semanas")
    
    start_time = time.time()
    
    async with async_playwright() as p:
        browser = await p.chromium.launch(
            channel=settings.browser_channel, 
            headless=settings.headless
        )
        page = await browser.new_page()
        
        try:
            # Login
            await page.goto("https://adalove.inteli.edu.br/")
            if not await login_adalove(page, settings.login, settings.senha, logger):
                logger.error("‚ùå Falha no login")
                return
            
            # Academic-life
            await navigate_to_academic_life(page, logger)
            
            # Continua extra√ß√£o das semanas restantes
            for i, semana in enumerate(semanas_pendentes, 1):
                logger.info(f"üîÑ {semana} ({i}/{len(semanas_pendentes)}) - RETOMADA")
                
                # Volta para academic-life antes de cada semana
                await page.goto("https://adalove.inteli.edu.br/academic-life")
                await page.wait_for_timeout(2000)
                
                # Fecha popup
                try:
                    fechar_btn = page.locator("button:has-text('Fechar')").first
                    if await fechar_btn.is_visible(timeout=2000):
                        await fechar_btn.click()
                        await page.wait_for_timeout(1000)
                except Exception:
                    pass
                
                # Extrai cards da semana
                cards_semana = await extract_week_cards(page, semana, logger)
                
                # SALVAMENTO INCREMENTAL
                incremental_writer.write_batch(cards_semana)
                incremental_writer.flush()
                
                # Cria backup da semana
                incremental_writer.create_week_backup(semana, cards_semana)
                
                # ATUALIZA CHECKPOINT
                checkpoint_mgr.mark_week_completed(semana, len(cards_semana))
                checkpoint_mgr.save()
                
                logger.info(f"‚úÖ Checkpoint: {semana} salva ({len(cards_semana)} cards)")
            
            # FINALIZA√á√ÉO
            checkpoint_mgr.mark_as_completed()
            all_cards = incremental_writer.finalize()  # Consolida JSONL temp
            
            # Salva arquivos finais + enriquecimento
            await save_and_enrich(all_cards, nome_turma, settings.output_dir, logger)
            
            # Limpeza de arquivos tempor√°rios
            checkpoint_mgr.cleanup()
            incremental_writer.cleanup()
            recovery_mgr.cleanup_after_recovery()
            
            # Resumo final
            duration = time.time() - start_time
            print_final_summary(all_cards, nome_turma, settings.output_dir, duration, logger)
                
        except Exception as e:
            # MARCA CHECKPOINT COMO FAILED (se foi inicializado)
            try:
                checkpoint_mgr.mark_as_failed(str(e))
                checkpoint_mgr.save()
            except RuntimeError:
                # Checkpoint n√£o foi inicializado ainda
                pass
            logger.error(f"‚ùå Erro geral: {e}")
            raise
        finally:
            await browser.close()
    

def print_final_summary(
    cards_data: list[dict], 
    nome_turma: str, 
    output_dir: str, 
    duration: float, 
    logger
) -> None:
    """
    Exibe resumo final da extra√ß√£o.
    
    Args:
        cards_data: Lista de cards extra√≠dos
        nome_turma: Nome da turma
        output_dir: Diret√≥rio de sa√≠da
        duration: Tempo total de execu√ß√£o
        logger: Logger
    """
    # Estat√≠sticas por semana
    stats = compute_stats_by_week(cards_data)
    logger.info("üìä Estat√≠sticas por semana:")
    for semana, dados in stats.items():
        logger.info(
            f"   {semana}: {dados['cards']} cards, "
            f"{dados['links']} links, {dados['materiais']} materiais"
        )
    
    # Resumo final
    semanas_processadas = len(set(card["semana"] for card in cards_data))
    total_links = sum(1 for card in cards_data if card.get("links"))
    total_materiais = sum(1 for card in cards_data if card.get("materiais"))
    
    print("\n" + "="*60)
    print("üéâ EXTRA√á√ÉO CONCLU√çDA COM SUCESSO!")
    print("="*60)
    print(f"üìä {len(cards_data)} cards extra√≠dos")
    print(f"üìö {semanas_processadas} semanas processadas")
    print(f"üîó {total_links} cards com links")
    print(f"üìé {total_materiais} cards com materiais")
    print(f"‚è±Ô∏è Tempo total: {duration:.1f}s")
    print(f"üìÅ Pasta: {output_dir}/{nome_turma}")
    print("="*60)
    
    logger.info("üéâ Extra√ß√£o finalizada com sucesso!")


async def save_and_enrich(
    cards_data: list[dict],
    nome_turma: str,
    output_base_dir: str,
    logger
) -> None:
    """
    Salva dados brutos e enriquecidos.
    
    Args:
        cards_data: Lista de cards extra√≠dos
        nome_turma: Nome da turma
        output_base_dir: Diret√≥rio base de sa√≠da
        logger: Logger
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    pasta_turma = f"{output_base_dir}/{nome_turma}"
    
    # Salva CSV bruto
    csv_bruto = f"{pasta_turma}/cards_completos_{timestamp}.csv"
    write_cards_csv(cards_data, csv_bruto, logger)
    
    # Estat√≠sticas por semana
    stats = compute_stats_by_week(cards_data)
    logger.info("üìä Estat√≠sticas por semana:")
    for semana, dados in stats.items():
        logger.info(
            f"   {semana}: {dados['cards']} cards, "
            f"{dados['links']} links, {dados['materiais']} materiais"
        )
    
    # Enriquecimento
    logger.info("üîß Enriquecendo registros (ancoragem robusta, normaliza√ß√µes)...")
    enrichment_engine = EnrichmentEngine(logger)
    enriched_data = enrichment_engine.enrich_cards(cards_data)
    
    # Salva CSV e JSONL enriquecidos
    csv_enriquecido, jsonl_enriquecido = write_enriched_outputs(
        enriched_data, pasta_turma, timestamp, logger
    )
    
    # Resumo final
    semanas_processadas = len(set(card["semana"] for card in cards_data))
    total_links = sum(1 for card in cards_data if card.get("links"))
    total_materiais = sum(1 for card in cards_data if card.get("materiais"))
    
    print("\n" + "="*60)
    print("üéâ EXTRA√á√ÉO CONCLU√çDA COM SUCESSO!")
    print("="*60)
    print(f"üìä {len(cards_data)} cards extra√≠dos")
    print(f"üìö {semanas_processadas} semanas processadas")
    print(f"üîó {total_links} cards com links")
    print(f"üìé {total_materiais} cards com materiais")
    print(f"üìÅ Pasta: {pasta_turma}")
    print(f"üíæ Arquivos gerados:")
    print(f"   - cards_completos_{timestamp}.csv")
    print(f"   - cards_enriquecidos_{timestamp}.csv")
    print(f"   - cards_enriquecidos_{timestamp}.jsonl")
    print("="*60)
    
    logger.info("üéâ Extra√ß√£o finalizada com sucesso!")


